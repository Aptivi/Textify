//
// Textify  Copyright (C) 2023-2024  Aptivi
//
// This file is part of Textify
//
// Textify is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Textify is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY, without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Textify.EmojiArrayGen
{
    [Generator]
    public class ArrayGenerator : IIncrementalGenerator
    {
        private static readonly Assembly asm = typeof(ArrayGenerator).Assembly;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            string header =
                $$"""
                //
                // Textify  Copyright (C) 2023-2024  Aptivi
                //
                // This file is part of Textify
                //
                // Textify is free software: you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation, either version 3 of the License, or
                // (at your option) any later version.
                //
                // Textify is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY, without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // You should have received a copy of the GNU General Public License
                // along with this program.  If not, see <https://www.gnu.org/licenses/>.
                //
                
                // <auto-generated/>

                using System.Collections.Generic;

                namespace Textify.Data.Unicode
                {
                    public static partial class EmojiManager
                    {
                
                """;
            string classFooter =
                $$"""
                    }
                    
                    /// <summary>
                    /// Emoji enumeration
                    /// </summary>
                    public enum EmojiEnum
                    {
                """;
            string footer =
                $$"""
                    }
                }
                """;
            var builder = new StringBuilder(header);
            var emojis = GetEmojis();

            // Populate the ultimate array for all emojis
            builder.Append(PopulateEmojiArray(emojis));
            builder.AppendLine(classFooter);
            builder.Append(PopulateEmojiEnum(emojis));

            // End the file
            builder.AppendLine(footer);
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("EmojiManager.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
            });
        }

        private static string PopulateEmojiEnum((string name, string refName, string sequence, string status)[] emojis)
        {
            var builder = new StringBuilder();
            for (int i = 0; i < emojis.Length; i++)
            {
                var (name, refName, sequence, status) = emojis[i];
                string xmlName = name.Replace("&", "&amp;");
                builder.AppendLine( "        /// <summary>");
                builder.AppendLine($"        /// [<see cref=\"{status}\"/>] Emoji enumeration for \"{xmlName}\" that represents \"{sequence}\"");
                builder.AppendLine( "        /// </summary>");
                builder.AppendLine($"        {refName},");
            }
            return builder.ToString();
        }

        private static string PopulateEmojiArray((string name, string refName, string sequence, string status)[] emojis)
        {
            string arrayFooter =
                $$"""
                        };
                
                """;
            string header =
                $$"""
                        private static readonly Dictionary<EmojiEnum, Emoji> emojis = new()
                        {
                
                """;
            var builder = new StringBuilder(header);
            for (int i = 0; i < emojis.Length; i++)
            {
                var (name, refName, sequence, status) = emojis[i];

                // Populate the EmojiEnum string
                string emojiEnumRef = $"EmojiEnum.{refName}";

                // Add the resultant emoji info
                builder.Append($"            {{ {emojiEnumRef}, new(\"{name}\", \"{sequence}\", {status}) }}");
                if (i < emojis.Length - 1)
                    builder.AppendLine(",");
            }
            builder.AppendLine("");
            builder.Append(arrayFooter);
            return builder.ToString();
        }

        private static (string name, string refName, string sequence, string status)[] GetEmojis()
        {
            // Open the stream that contains the emoji list
            var stream = asm.GetManifestResourceStream($"{asm.GetName().Name}.emoji-test.txt") ??
                throw new Exception("Failed to find emoji test text file.");

            // Add the whole list, ignoring the comments and the empty lines
            var reader = new StreamReader(stream);
            var emojis = new List<(string name, string refName, string sequence, string status)>();
            List<string> processedRefs = [];
            int iteration = 0;
            while (!reader.EndOfStream)
            {
                // Get a line and ignore comments and empty lines
                var line = reader.ReadLine();
                if (string.IsNullOrEmpty(line) || line.StartsWith("#"))
                    continue;

                // Now, find the name, the sequence, and the status separator in this format:
                // code points; status # emoji name
                if (!line.Contains(";") || !line.Contains("#"))
                    throw new Exception($"This line [{line}] doesn't have the necessary separators.");

                // Use the separators to split the values
                int cpSepIdx = line.IndexOf(";");
                int statusSepIdx = line.IndexOf("#");
                string codePoints = line.Substring(0, cpSepIdx).Trim();
                string status = line.Substring(cpSepIdx + 1, statusSepIdx - cpSepIdx - 1).Trim();
                string name = line.Substring(statusSepIdx + 1).Trim();

                // Now, split the code points with the space and reform them into character instances in a string
                string[] splitCp = codePoints.Split(' ');
                var seqBuilder = new StringBuilder();
                foreach (string cp in splitCp)
                    seqBuilder.Append(cp.Length == 5 ? $@"\U000{cp}" : $@"\u{cp}");
                string sequence = seqBuilder.ToString();

                // Enumerate the status
                string statusEnumRef = status switch
                {
                    "component"             => "EmojiStatus.Component",
                    "fully-qualified"       => "EmojiStatus.FullyQualified",
                    "minimally-qualified"   => "EmojiStatus.MinimalQualified",
                    "unqualified"           => "EmojiStatus.NotQualified",
                    _ =>
                        throw new Exception($"Status [{status}] is not valid"),
                };

                // Make the referencable names. Any character that doesn't exist in ASCII should be placed as
                // Unicode escapes in the oldValue parameter.
                string safeName = name
                    .Replace(":", "")
                    .Replace("-", "")
                    .Replace(",", "")
                    .Replace(".", "")
                    .Replace("\u2019", "")
                    .Replace("#", "")
                    .Replace("*", "")
                    .Replace("(", "")
                    .Replace(")", "")
                    .Replace("\u201c", "")
                    .Replace("\u201d", "")
                    .Replace("!", "")
                    .Replace("&", "")
                ;
                string[] nameSplit = name.Split(' ').Skip(2).ToArray();
                string[] sharpNameSplit = safeName.Split(' ').Skip(2).Select((name) =>
                {
                    if (string.IsNullOrEmpty(name))
                        return "";
                    var chars = name.ToCharArray();
                    chars[0] = char.ToUpper(chars[0]);
                    return char.IsNumber(chars[0]) ? $"Num{new string(chars)}" : new string(chars);
                }).ToArray();
                name = string.Join(" ", nameSplit);
                string refName = string.Join("", sharpNameSplit);

                // Check for conflicts
                while (processedRefs.Contains(refName))
                {
                    iteration++;
                    refName = $"{refName}{iteration}";
                }
                if (!processedRefs.Contains(refName))
                    processedRefs.Add(refName);
                iteration = 0;

                // Add the final values
                emojis.Add((name, refName, sequence, statusEnumRef));
            }
            return [.. emojis];
        }
    }
}
