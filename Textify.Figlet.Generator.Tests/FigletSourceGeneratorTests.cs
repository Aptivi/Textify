//
// Textify  Copyright (C) 2023-2024  Aptivi
//
// This file is part of Textify
//
// Textify is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Textify is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY, without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
//

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Shouldly;

namespace Textify.Figlet.Generator.Tests
{
    [TestClass]
    public class FigletSourceGeneratorTests
    {
        private readonly ImmutableArray<MetadataReference> _references;
        private const string Header =
            """

            // <auto-generated>
            //     This code was generated by Textify.Figlet.Generator.
            //
            //     Changes to this file may cause incorrect behavior and will be lost if
            //     the code is regenerated.
            // </auto-generated>

            """;

        public FigletSourceGeneratorTests()
        {
            _references = GetReferences().ToImmutableArray();

            static IEnumerable<MetadataReference> GetReferences()
            {
                foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
                {
                    if (!assembly.IsDynamic && !string.IsNullOrWhiteSpace(assembly.Location))
                    {
                        yield return MetadataReference.CreateFromFile(assembly.Location);
                    }
                }
            }
        }

        [TestMethod]
        public void SimpleCase_Class()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal partial class DemoUsage
                    {
                    }
                }
                """;
            string expected =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class DemoUsage
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;

            ValidateOutput(source, expected);
        }

        [TestMethod]
        public void SimpleCase_StaticClass()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;
            string expected =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class DemoUsage
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;

            ValidateOutput(source, expected);
        }

        [TestMethod]
        public void SimpleCase_GlobalNamespace()
        {
            string source =
                """
                [GenerateFigletText("Member", "stacey", "Figlet")]
                internal static partial class DemoUsage
                {
                }
                """;
            string expected =
                $$"""
                {{Header}}
                partial class DemoUsage
                {
                    public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                }

                """;

            ValidateOutput(source, expected);
        }

        [TestMethod]
        public void MultipleStrings()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("HelloWorldString", "blocks", "Hello world")]
                    [GenerateFigletText("FigletString", "stacey", "Figlet")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;
            string expected =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class DemoUsage
                    {
                        public static string HelloWorldString { get; } = @" .----------------.  .----------------.  .----------------.  .----------------.  .----------------.   .----------------.  .----------------.  .----------------.  .----------------.  .----------------. 
                | .--------------. || .--------------. || .--------------. || .--------------. || .--------------. | | .--------------. || .--------------. || .--------------. || .--------------. || .--------------. |
                | |  ____  ____  | || |  _________   | || |   _____      | || |   _____      | || |     ____     | | | | _____  _____ | || |     ____     | || |  _______     | || |   _____      | || |  ________    | |
                | | |_   ||   _| | || | |_   ___  |  | || |  |_   _|     | || |  |_   _|     | || |   .'    `.   | | | ||_   _||_   _|| || |   .'    `.   | || | |_   __ \    | || |  |_   _|     | || | |_   ___ `.  | |
                | |   | |__| |   | || |   | |_  \_|  | || |    | |       | || |    | |       | || |  /  .--.  \  | | | |  | | /\ | |  | || |  /  .--.  \  | || |   | |__) |   | || |    | |       | || |   | |   `. \ | |
                | |   |  __  |   | || |   |  _|  _   | || |    | |   _   | || |    | |   _   | || |  | |    | |  | | | |  | |/  \| |  | || |  | |    | |  | || |   |  __ /    | || |    | |   _   | || |   | |    | | | |
                | |  _| |  | |_  | || |  _| |___/ |  | || |   _| |__/ |  | || |   _| |__/ |  | || |  \  `--'  /  | | | |  |   /\   |  | || |  \  `--'  /  | || |  _| |  \ \_  | || |   _| |__/ |  | || |  _| |___.' / | |
                | | |____||____| | || | |_________|  | || |  |________|  | || |  |________|  | || |   `.____.'   | | | |  |__/  \__|  | || |   `.____.'   | || | |____| |___| | || |  |________|  | || | |________.'  | |
                | |              | || |              | || |              | || |              | || |              | | | |              | || |              | || |              | || |              | || |              | |
                | '--------------' || '--------------' || '--------------' || '--------------' || '--------------' | | '--------------' || '--------------' || '--------------' || '--------------' || '--------------' |
                 '----------------'  '----------------'  '----------------'  '----------------'  '----------------'   '----------------'  '----------------'  '----------------'  '----------------'  '----------------' ";
                        public static string FigletString { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;

            ValidateOutput(source, expected);
        }

        [TestMethod]
        public void SimpleCase_TwoClasses_SameNamespace()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal partial class Demo1
                    {
                    }

                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal partial class Demo2
                    {
                    }
                }
                """;
            string expected1 =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class Demo1
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;
            string expected2 =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class Demo2
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;

            ValidateOutput(source, expected1, expected2);
        }

        [TestMethod]
        public void SimpleCase_TwoClasses_DifferentNamespace()
        {
            string source =
                """
                namespace Test.Namespace1
                {
                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal partial class Demo
                    {
                    }
                }

                namespace Test.Namespace2
                {
                    [GenerateFigletText("Member", "stacey", "Figlet")]
                    internal partial class Demo
                    {
                    }
                }
                """;
            string expected1 =
                $$"""
                {{Header}}
                namespace Test.Namespace1
                {
                    partial class Demo
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;
            string expected2 =
                $$"""
                {{Header}}
                namespace Test.Namespace2
                {
                    partial class Demo
                    {
                        public static string Member { get; } = @"______________________   _______________
                7     77  77     77  7   7     77      7
                |  ___!|  ||   __!|  |   |  ___!!__  __!
                |  __| |  ||  !  7|  !___|  __|_  7  7  
                |  7   |  ||     ||     7|     7  |  |  
                !__!   !__!!_____!!_____!!_____!  !__!  ";
                    }
                }
                """;

            ValidateOutput(source, expected1, expected2);
        }

        [TestMethod]
        public void InvalidFontName()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "unknown-font", "Bar")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.UnknownFontNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("A font with name 'unknown-font' was not found");
        }

        [TestMethod]
        public void InvalidMemberName()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("With Space", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.InvalidMemberNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("The string 'With Space' is not a valid member name");
        }

        [TestMethod]
        public void DuplicateMemberName_SamePart()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;

            var (compilation, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.DuplicateMemberNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Member 'Foo' has already been declared");

            string expected =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class DemoUsage
                    {
                        public static string Foo { get; } = @"_____________________
                7     77     77     7
                |  ___!|  7  ||  7  |
                |  __| |  |  ||  |  |
                |  7   |  !  ||  !  |
                !__!   !_____!!_____!";
                    }
                }
                """;

            compilation.SyntaxTrees.Last().ToString().ShouldBe(expected, NewlineIgnoreComparer.Instance);
        }

        [TestMethod]
        public void MemberAlreadyExists_SamePart()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                        public static void Foo() {}
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.DuplicateMemberNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Member 'Foo' has already been declared");
        }

        [TestMethod]
        public void MemberAlreadyExists_DifferentPart()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                    }

                    internal static partial class DemoUsage
                    {
                        public static void Foo() {}
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.DuplicateMemberNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Member 'Foo' has already been declared");
        }

        [TestMethod]
        public void DuplicateMemberName_DifferentParts()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                    }

                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal static partial class DemoUsage
                    {
                    }
                }
                """;

            var (compilation, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.DuplicateMemberNameDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Member 'Foo' has already been declared");

            string expected =
                $$"""
                {{Header}}
                namespace Test.Namespace
                {
                    partial class DemoUsage
                    {
                        public static string Foo { get; } = @"_____________________
                7     77     77     7
                |  ___!|  7  ||  7  |
                |  __| |  |  ||  |  |
                |  7   |  !  ||  !  |
                !__!   !_____!!_____!";
                    }
                }
                """;

            compilation.SyntaxTrees.Last().ToString().ShouldBe(expected, NewlineIgnoreComparer.Instance);
        }

        [TestMethod]
        public void TypeIsNotPartial()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    [GenerateFigletText("Foo", "stacey", "Foo")]
                    internal class DemoUsage
                    {
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.TypeIsNotPartialDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Type 'DemoUsage' must be partial");
        }

        [TestMethod]
        public void NestedTypeIsNotSupported()
        {
            string source =
                """
                namespace Test.Namespace
                {
                    internal partial class Outer
                    {
                        [GenerateFigletText("Foo", "stacey", "Foo")]
                        internal partial class Inner
                        {
                        }
                    }
                }
                """;

            var (_, diagnostics) = RunGenerator(source);

            var diagnostic = diagnostics.ShouldHaveSingleItem();

            Assert.AreSame(FigletSourceGenerator.NestedTypeIsNotSupportedDiagnostic, diagnostic.Descriptor);
            diagnostic.GetMessage().ShouldBe("Unable to generate Figlet text for nested type 'Inner'. Generation is only supported for non-nested types.");
        }

        private void ValidateOutput(string source, params string[] outputs)
        {
            var (compilation, diagnostics) = RunGenerator(source);

            ValidateNoErrors(diagnostics);

            compilation.SyntaxTrees.Select(tree => tree.ToString()).ShouldBe(new[] { source, FigletSourceGenerator.AttributeSource }.Concat(outputs), NewlineIgnoreComparer.Instance);
        }

        private (Compilation Compilation, ImmutableArray<Diagnostic> Diagnostics) RunGenerator(string source)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(source);

            var compilation = CSharpCompilation.Create(
                "testAssembly",
                [syntaxTree],
                _references,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            ISourceGenerator generator = new FigletSourceGenerator();

            var driver = CSharpGeneratorDriver.Create(generator);

            driver.RunGeneratorsAndUpdateCompilation(
                compilation,
                out var outputCompilation,
                out var generateDiagnostics);

            return (outputCompilation, generateDiagnostics);
        }

        private static void ValidateNoErrors(ImmutableArray<Diagnostic> diagnostics)
        {
            var errors = diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToList();

            if (errors.Count != 0)
            {
                throw new Exception(
                    string.Join(
                        Environment.NewLine,
                        errors.Select(error => error.GetMessage())));
            }
        }

        private sealed class NewlineIgnoreComparer : IEqualityComparer<string>
        {
            public static NewlineIgnoreComparer Instance { get; } = new();

            public bool Equals(string x, string y)
            {
                return StringComparer.Ordinal.Equals(Normalize(x), Normalize(y));
            }

            public int GetHashCode(string obj)
            {
                return StringComparer.Ordinal.GetHashCode(Normalize(obj));
            }

            private static string Normalize(string s) => s?.Replace("\r", "") ?? "";
        }
    }
}
